<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TapTempo — BPM Calculator</title>
<style>
  :root{--bg:#fbfdff;--card:#fff;--accent:#0b66ff;--muted:#556;--glass:rgba(11,102,255,0.06)}
  *{box-sizing:border-box;font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  body{margin:0;background:linear-gradient(180deg,var(--bg),#f2f7ff);color:#07203a;min-height:100vh;display:flex;align-items:center;justify-content:center;padding:28px}
  .wrap{width:960px;max-width:100%;display:grid;grid-template-columns:1fr 360px;gap:20px}
  .card{background:var(--card);padding:20px;border-radius:12px;box-shadow:0 6px 18px rgba(8,20,40,0.06)}
  h1{margin:0 0 6px;font-size:20px}
  .lead{color:var(--muted);font-size:13px;margin-bottom:14px}
  .bpm-display{font-weight:700;font-size:64px;text-align:center;padding:20px;border-radius:10px;background:linear-gradient(90deg,var(--glass),transparent);margin-bottom:10px}
  .controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  button{cursor:pointer;padding:10px 14px;border-radius:8px;border:1px solid rgba(7,32,58,0.06);background:#fff;font-weight:600}
  .tap-btn{background:var(--accent);color:#fff;border:none;font-size:18px;padding:14px 20px}
  .small{font-size:13px;color:var(--muted)}
  .history{margin-top:12px;display:flex;gap:8px;flex-wrap:wrap}
  .chip{background:#f6fbff;padding:6px 10px;border-radius:999px;border:1px solid rgba(7,32,58,0.04);font-size:13px}
  .right{padding-left:12px}
  input[type=file]{display:none}
  label.filebtn{display:inline-block;padding:10px 12px;border-radius:8px;border:1px dashed rgba(7,32,58,0.08);background:#fff;cursor:pointer}
  canvas{width:100%;height:80px;border-radius:8px;background:#fbfdff}
  .meta{font-size:13px;color:var(--muted);margin-top:8px}
  .note{font-size:12px;color:#334;opacity:.8;margin-top:10px}
  footer{grid-column:1/-1;text-align:center;color:var(--muted);font-size:12px;margin-top:12px}
  @media (max-width:880px){.wrap{grid-template-columns:1fr;}}
</style>
</head>
<body>
  <div class="wrap">
    <!-- Left: main -->
    <div class="card">
      <h1>BPM (Beats Per Minute) Calculator</h1>
      <div class="lead">Tap the button with the beat or upload an audio file to estimate tempo.</div>

      <div class="bpm-display" id="bpmDisplay">—</div>

      <div class="controls">
        <button id="tapBtn" class="tap-btn" title="Tap spacebar">Tap</button>
        <button id="resetBtn">Reset</button>
        <button id="copyBtn">Copy BPM</button>
        <label class="filebtn" for="fileInput">Upload Audio</label>
        <input id="fileInput" type="file" accept="audio/*">
      </div>

      <div class="history" id="history"></div>
      <div class="meta" id="metaInfo">Taps: 0 · Smoothed BPM: — · Raw BPM: —</div>

      <div style="margin-top:14px">
        <canvas id="waveCanvas" width="600" height="80"></canvas>
        <div class="note">Waveform / onset envelope (visual aid). Peaks are used to estimate tempo.</div>
      </div>
    </div>

    <!-- Right: explanation & tips -->
    <div class="card right">
      <h2 style="margin:0 0 8px">How it works</h2>
      <p class="small">Tap tempo: each tap records a timestamp; compute time between taps (Δt); BPM = 60 / Δt. Use multiple taps and averaging to stabilize the result.</p>

      <h3 style="margin-top:12px;margin-bottom:6px">Features</h3>
      <ul class="small" style="padding-left:18px">
        <li>Tap-based BPM with smoothing</li>
        <li>Upload audio file → client-side BPM estimate</li>
        <li>Visual onset envelope and peak detection</li>
        <li>Copy BPM and quick reset</li>
      </ul>

      <h3 style="margin-top:12px;margin-bottom:6px">Usage tips</h3>
      <ol class="small" style="padding-left:18px">
        <li>Tap steadily (4–8 taps) for stable value.</li>
        <li>For audio file detection, use clear music with a strong beat.</li>
        <li>Press <strong>Space</strong> to tap quickly.</li>
      </ol>

      <div style="margin-top:10px">
        <strong>Deploy:</strong> Host on GitHub Pages or Netlify (static site).<br>
        <span class="small">No backend required for these features.</span>
      </div>
    </div>

    <footer class="card" style="text-align:center">Built with Web Audio API • Simple DSP • Suitable for GitHub Pages</footer>
  </div>

<script>
/* ---------- Tap tempo logic ---------- */
const tapBtn = document.getElementById('tapBtn');
const resetBtn = document.getElementById('resetBtn');
const copyBtn = document.getElementById('copyBtn');
const bpmDisplay = document.getElementById('bpmDisplay');
const historyDiv = document.getElementById('history');
const metaInfo = document.getElementById('metaInfo');

let taps = [];           // timestamps in seconds
let smoothedBPM = null;
let lastRawBPM = null;
const SMOOTH_ALPHA = 0.25; // exponential smoothing amount (0-1)

function updateUI() {
  historyDiv.innerHTML = '';
  taps.slice(-8).forEach((t,i)=> {
    const el = document.createElement('div'); el.className='chip'; el.textContent=(i===taps.length-1? '• ':'') + (new Date(t*1000)).toLocaleTimeString();
    historyDiv.appendChild(el);
  });
  bpmDisplay.textContent = smoothedBPM ? Math.round(smoothedBPM) : '—';
  metaInfo.textContent = `Taps: ${taps.length} · Smoothed BPM: ${smoothedBPM?Math.round(smoothedBPM):'—'} · Raw BPM: ${lastRawBPM?Math.round(lastRawBPM):'—'}`;
}

function addTap(ts) {
  taps.push(ts);
  // keep reasonable history
  if(taps.length>100) taps = taps.slice(-100);
  if(taps.length>=2) {
    // compute average interval between first and last of recent window (last N taps)
    const N = Math.min(6, taps.length);
    const recent = taps.slice(-N);
    const avgInterval = (recent[recent.length-1] - recent[0]) / (recent.length - 1);
    const rawBPM = 60 / avgInterval;
    lastRawBPM = rawBPM;
    // exponential smoothing to stabilize
    if(smoothedBPM == null) smoothedBPM = rawBPM;
    else smoothedBPM = (SMOOTH_ALPHA * rawBPM) + ((1 - SMOOTH_ALPHA) * smoothedBPM);
  }
  updateUI();
}

tapBtn.addEventListener('click', () => addTap(performance.now()/1000));
resetBtn.addEventListener('click', () => { taps=[]; smoothedBPM=null; lastRawBPM=null; updateUI(); clearCanvas(); });

copyBtn.addEventListener('click', async () => {
  if(!smoothedBPM) return alert('No BPM to copy');
  try { await navigator.clipboard.writeText(Math.round(smoothedBPM).toString()); alert('BPM copied'); } catch(e){ alert('Copy failed'); }
});

window.addEventListener('keydown', (e)=> { if(e.code === 'Space') { e.preventDefault(); addTap(performance.now()/1000); } });

/* ---------- Audio file BPM detection ---------- */
const fileInput = document.getElementById('fileInput');
const waveCanvas = document.getElementById('waveCanvas');
const ctx = waveCanvas.getContext('2d');

fileInput.addEventListener('change', async (ev) => {
  const file = ev.target.files && ev.target.files[0];
  if(!file) return;
  try {
    const arrayBuffer = await file.arrayBuffer();
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await audioCtx.decodeAudioData(arrayBuffer);
    // perform onset / energy-based peak detection
    const channelData = decoded.numberOfChannels>0 ? decoded.getChannelData(0) : decoded.getChannelData(0);
    const sampleRate = decoded.sampleRate;
    // parameters
    const frameSize = 1024; // window for energy
    const hop = 512;
    const energies = [];
    for(let i=0;i+frameSize<channelData.length;i+=hop){
      let sum=0;
      for(let j=0;j<frameSize;j++){
        const s = channelData[i+j];
        sum += Math.abs(s);
      }
      energies.push(sum);
    }
    // normalize energies
    const eMax = Math.max(...energies);
    const norm = energies.map(e => e / (eMax || 1));
    // smooth envelope with moving average
    const smooth = movingAverage(norm, 4);
    // detect peaks: local max above threshold (mean + k*std)
    const mean = smooth.reduce((a,b)=>a+b,0)/smooth.length;
    const std = Math.sqrt(smooth.reduce((a,b)=>a+(b-mean)**2,0)/smooth.length);
    const threshold = mean + Math.max(0.08, std * 0.9); // adaptive
    const peaks = [];
    for(let i=1;i<smooth.length-1;i++){
      if(smooth[i] > smooth[i-1] && smooth[i] >= smooth[i+1] && smooth[i] > threshold){
        // convert frame index to time
        const time = (i * hop) / sampleRate;
        peaks.push(time);
      }
    }
    // if too few peaks, relax threshold
    if(peaks.length < 4){
      // try lower threshold
      const thr2 = mean + Math.max(0.03, std * 0.3);
      for(let i=1;i<smooth.length-1;i++){
        if(smooth[i] > smooth[i-1] && smooth[i] >= smooth[i+1] && smooth[i] > thr2){
          const time = (i * hop) / sampleRate;
          if(peaks.length===0 || Math.abs(peaks[peaks.length-1]-time) > 0.08) peaks.push(time);
        }
      }
    }
    // compute BPM from peak intervals
    if(peaks.length >= 2){
      const intervals = [];
      for(let i=1;i<peaks.length;i++) intervals.push(peaks[i]-peaks[i-1]);
      const avgInterval = intervals.reduce((a,b)=>a+b,0)/intervals.length;
      const bpm = 60 / avgInterval;
      // handle doubling/halving errors: common to get 2x tempo; normalize to common range 60-180
      const normalized = normalizeBPM(bpm);
      smoothedBPM = normalized;
      lastRawBPM = bpm;
      updateUI();
      drawEnvelope(smooth, threshold, peaks);
      alert('Estimated BPM: ' + Math.round(normalized) + ' (raw: ' + Math.round(bpm) + ')');
    } else {
      alert('Could not detect enough beats. Try a track with a stronger consistent beat.');
      drawEnvelope(smooth, threshold, peaks);
    }
  } catch(err){
    console.error(err);
    alert('Error decoding audio file.');
  }
});

/* ---------- Helper functions ---------- */
function movingAverage(arr, window){
  const out = [];
  for(let i=0;i<arr.length;i++){
    let sum=0, cnt=0;
    for(let j=i-(window-1); j<=i; j++){
      if(j>=0 && j<arr.length){ sum+=arr[j]; cnt++; }
    }
    out.push(sum / (cnt||1));
  }
  return out;
}
function normalizeBPM(bpm){
  // move bpm into 60-180 by doubling/halving
  let b = bpm;
  while(b < 60) b*=2;
  while(b > 180) b/=2;
  return b;
}

/* ---------- Canvas drawing ---------- */
function clearCanvas(){
  ctx.clearRect(0,0,waveCanvas.width,waveCanvas.height);
  ctx.fillStyle = '#fff';
  ctx.fillRect(0,0,waveCanvas.width,waveCanvas.height);
}
function drawEnvelope(envelope, threshold, peaks){
  const w = waveCanvas.width, h = waveCanvas.height;
  clearCanvas();
  ctx.beginPath();
  ctx.moveTo(0, h);
  for(let i=0;i<envelope.length;i++){
    const x = (i/envelope.length)*w;
    const y = h - envelope[i]*h;
    ctx.lineTo(x,y);
  }
  ctx.lineTo(w,h);
  ctx.fillStyle = '#eff8ff';
  ctx.fill();
  // draw threshold line
  ctx.beginPath();
  ctx.moveTo(0, h - threshold*h);
  ctx.lineTo(w, h - threshold*h);
  ctx.strokeStyle = '#cfe6ff';
  ctx.lineWidth=1;
  ctx.stroke();
  // draw peaks
  ctx.fillStyle = '#0b66ff';
  peaks.forEach(p => {
    const x = (p / (envelope.length)) * w *  (envelope.length / envelope.length); // simplistic mapping
    // better map index: find index closest to time/timePerFrame
    // but for display we approximate using p/timeSpan
    // approximate timeSpan = envelope.length * hop / sr ; we don't pass these in; it's ok visually
    ctx.beginPath();
    ctx.arc(x, 12, 4, 0, Math.PI*2);
    ctx.fill();
  });
}

/* init clear */
clearCanvas();
</script>
</body>
</html>
